#+TITLE: simultaneous-productions
#+STARTUP: showall

A Scala parser combinator library efficiently implementing "simultaneous productions", a model equivalent to a Turing Machine (I think). The method of simultaneous productions allows specifying languages extremely naturally, and maps perfectly to the parser combinator operations I have in mind. It can also be implemented with a linear (?) partitioning algorithm.

* Ideal Code

#+BEGIN_SRC rust

#+END_SRC

#+BEGIN_SRC scala
val FloatingPointLiteral = sp.productions(
  ("float-signed" -> Cases(Parser(Tok("-") * Ref("float-unsigned"), { - _._2 }),
                           Parser(Tok("+") * Ref("float-unsigned"), { _._2 }))),
  // NB: should make sure sp.NumberLiterals returns 0 for an empty string
  ("float-base" -> SingleCase(sp.NumberLiterals)),
  ("float-mantissa" -> SingleCase(sp.NumberLiterals)),
  ("float-unsigned" -> Cases(Parser(Ref("float-base"), { toFloat(sp.parseIntegral(_._1)) }),
                             Parser(Ref("float-base") * Tok(".") * Ref("float-mantissa"), {
                               // glossing over the details of converting e.g. ".123" to 1/10 + 2/10 + 3/10
                               case (base, _, mantissa) => toFloat(sp.parseIntegral(base)) + sp.parseFloat(mantissa)
                             }))),
  ("exponent" -> Cases(Parser(Tok("e") * Ref("exponent-negated")),
                       Parser(Tok("e") * Ref("exponent-unsigned")))),
  ("exponent-negated" -> SingleCase(Parser(Tok("-") * Ref("exponent-unsigned")))),
  // sp.NumberLiterals is a whole Parser, and should probably return a string
  ("exponent-unsigned" -> SingleCase(sp.NumberLiterals)),
)

val WithWeirdIntegerLiterals = Grammars.C.productions.entry[IntegerLiteral] // Use a type-indexed map!
  .replaceCases
  .addCase(('A', SomeSubProductionType, 'C') ~> { (a: Token, inner: SomeSubProductionType, c: Token) =>
    IntegerLiteral(s"${a}${inner.toString}${c}")
  }.build() // This could be hidden behind an implicit.
)
#+END_SRC

* TODO [0/6]
- [ ] specify a simple language so that it compiles
  - use fixed strings instead of regex for now
  - use strings instead of type-indexing the productions for now
- [ ] implement the simple language so that it can be parsed
- [ ] figure out how to allow productions to be type-indexed and require type-checking for that type in all the cases of the production
- [ ] make a simple language that is usable for some simple task
  - csv parsing? /or at least a simple subset of it/
- [ ] develop benchmarking and (fuzz)? testing methods
- [ ] parse C and C++

* LICENSE
[[file:./LICENSE][GPL 3.0+]]
